<?php
// This file is part of Moodle - https://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.

/**
 * The main mod_assignquiz configuration form.
 *
 * @package     mod_assignquiz
 * @copyright   2024 Zakaria Lasry Sahraou zsahraoui20@gmail.com
 * @license     https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

use setasign\Fpdi\Fpdi;


defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot.'/course/moodleform_mod.php');
require_once($CFG->dirroot.'/mod/quiz/mod_form.php');
require_once($CFG->dirroot.'/mod/quiz/locallib.php');
require_once($CFG->dirroot.'/mod/assignquiz/locallib.php');
require_once($CFG->dirroot.'/grade/querylib.php');
require_once($CFG->dirroot.'/vendor/autoload.php');
require_once($CFG->dirroot.'/question/type/multichoice/questiontype.php'); // Add this line

class mod_assignquiz_mod_form extends mod_quiz_mod_form {


    /**
     * Defines forms elements
     */

    protected function definition()
    {
        global $DB, $CFG;
        parent::definition(); // TODO: Change the autogenerated stub
        $mform = $this->_form;
        $mform->setDefault('preferredbehaviour', 'deferredfeedback');
        $mform->setDefault('decimalpoints', 2);
        $mform->setDefault('questiondecimalpoints', -1);
        //feedback will be ai generated, so no need for these elements
        $mform->removeElement('overallfeedbackhdr');
        $mform->removeElement('gradeboundarystatic1');
        $mform->removeElement('gradeboundarystatic2');
        $mform->removeElement('boundary_repeats');
        $mform->removeElement('boundary_add_fields');
        $mform->removeElement('feedbacktext[0]');

    }
    public function data_preprocessing(&$toform)
    {

        if (isset($toform['grade'])) {
            // Convert to a real number, so we don't get 0.0000.
            $toform['grade'] = $toform['grade'] + 0;
        }
        if (count($this->_feedbacks)) {
            $key = 0;
            foreach ($this->_feedbacks as $feedback) {
                $draftid = file_get_submitted_draft_itemid('feedbacktext['.$key.']');
                $toform['feedbacktext['.$key.']']['text'] = file_prepare_draft_area(
                    $draftid,               // Draftid.
                    $this->context->id,     // Context.
                    'mod_quiz',             // Component.
                    'feedback',             // Filarea.
                    !empty($feedback->id) ? (int) $feedback->id : null, // Itemid.
                    null,
                    $feedback->feedbacktext // Text.
                );
                $toform['feedbacktext['.$key.']']['format'] = $feedback->feedbacktextformat;
                $toform['feedbacktext['.$key.']']['itemid'] = $draftid;

                if ($toform['grade'] == 0) {
                    // When a quiz is un-graded, there can only be one lot of
                    // feedback. If the quiz previously had a maximum grade and
                    // several lots of feedback, we must now avoid putting text
                    // into input boxes that are disabled, but which the
                    // validation will insist are blank.
                    break;
                }

                if ($feedback->mingrade > 0) {
                    $toform['feedbackboundaries['.$key.']'] =
                        round(100.0 * $feedback->mingrade / $toform['grade'], 6) . '%';
                }
                $key++;
            }
        }

        if (isset($toform['timelimit'])) {
            $toform['timelimitenable'] = $toform['timelimit'] > 0;
        }

        $this->preprocessing_review_settings($toform, 'during',
            mod_quiz_display_options::DURING);
        $this->preprocessing_review_settings($toform, 'immediately',
            mod_quiz_display_options::IMMEDIATELY_AFTER);
        $this->preprocessing_review_settings($toform, 'open',
            mod_quiz_display_options::LATER_WHILE_OPEN);
        $this->preprocessing_review_settings($toform, 'closed',
            mod_quiz_display_options::AFTER_CLOSE);
        $toform['attemptduring'] = true;
        $toform['overallfeedbackduring'] = false;



        // Password field - different in form to stop browsers that remember
        // passwords from getting confused.
        if (isset($toform['password'])) {
            $toform['quizpassword'] = $toform['password'];
            unset($toform['password']);
        }

        // Load any settings belonging to the access rules.
        if (!empty($toform['instance'])) {
            $accesssettings = aiquiz_access_manager::load_settings($toform['instance']);
            foreach ($accesssettings as $name => $value) {
                $toform[$name] = $value;
            }
        }

        if (empty($toform['completionminattempts'])) {
            $toform['completionminattempts'] = 1;
        } else {
            $toform['completionminattemptsenabled'] = $toform['completionminattempts'] > 0;
        }
    }
//    public function data_postprocessing($data)
//    {
//        global $CFG, $DB;
//        $dotenv = Dotenv\Dotenv::createImmutable(__DIR__);
//        $dotenv->safeLoad();
//        parent::data_postprocessing($data);
//        $section_name = $DB->get_field('course_sections', 'name', ['section' => $this->_section, 'course' => $this->_course->id]);
//        $section_name = $section_name  == null ? 'Seccion sin nombre definido (nombre por defecto de Moodle)': $section_name;
//
//        $existing_category = $DB->get_record('question_categories', ['name' => 'Preguntas de la sección: '.$section_name]);
//
//        if (!$existing_category) {
//            $question_category_id = $this->create_question_category($this->_section);
//        } else {
//            $question_category_id = $existing_category->id;
//        }
//
//        $tempDir = $this->get_temp_directory($CFG);
//        $pdfFiles = $this->process_pdfs($tempDir);
//
//        if (empty($pdfFiles)) {
//            error_log("No PDFs found to process.");
//            return;
//        }
//
//        if (count($pdfFiles) === 1) {
//            $mergedPdfTempFilename = $pdfFiles[0];
//        } else {
//            $mergedPdfTempFilename = $this->merge_pdfs($pdfFiles, $tempDir);
//        }
//
//        if ($mergedPdfTempFilename) {
//            $response = $this->process_merged_pdf($mergedPdfTempFilename);
//            $formattedResponse = $this->format_text($response);
//            error_log(print_r($formattedResponse, true));
//            $this->add_question_to_question_bank($formattedResponse, $question_category_id);
//            unlink($mergedPdfTempFilename);
//        } else {
//            error_log("Error processing PDFs.");
//        }
//    }


    private function get_temp_directory($CFG)
    {
        $tempDir = $CFG->dataroot . '/temp/assignquiz_pdf/';
        if (!file_exists($tempDir)) {
            mkdir($tempDir, 0777, true);
        }
        return $tempDir;
    }

    private function process_pdfs($tempDir)
    {
        $fs = get_file_storage();
        $pdfFiles = [];
        $files = $this->get_pdfs_in_section();

        foreach ($files as $pdf) {
            $pdfFile = $fs->get_file($pdf->contextid, $pdf->component, $pdf->filearea, $pdf->itemid, $pdf->filepath, $pdf->filename);
            $file_content = $pdfFile->get_content();

            $tempFilename = $tempDir . uniqid('moodle_pdf_', true) . '.pdf';
            file_put_contents($tempFilename, $file_content);

            $convertedFile = $this->convert_pdf($tempFilename, $tempDir);
            if ($convertedFile) {
                $pdfFiles[] = $convertedFile;
            }
            unlink($tempFilename);
        }
        return $pdfFiles;
    }

    private function convert_pdf($inputFile, $tempDir)
    {
        $outputFile = $tempDir . uniqid('converted_moodle_pdf_', true) . '.pdf';
        $gsCmd = 'gswin64c.exe -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dNOPAUSE -dBATCH -sOutputFile="' . $outputFile . '" "' . $inputFile . '" 2>&1';
        exec($gsCmd, $output, $returnVar);
        return $outputFile;
    }

    private function merge_pdfs($pdfFiles, $tempDir)
    {
        $mergedPdfTempFilename = $tempDir . uniqid('merged_moodle_pdf_', true) . '.pdf';

        $mergeResult = $this->mergePDFs($pdfFiles, $mergedPdfTempFilename);
        foreach ($pdfFiles as $pdfFile) {
            unlink($pdfFile);
        }

        return $mergeResult ? $mergedPdfTempFilename : null;
    }

    private function create_question_category($section_id) {
        global $DB;
        $context_id = $DB->get_field('context', 'id', ['contextlevel' => 50, 'instanceid' => $this->_course->id]);
        $question_category = new stdClass();
        $section_name = $DB->get_field('course_sections', 'name', ['section' => $section_id, 'course' => $this->_course->id]);
        $section_name = $section_name  == null ? 'Seccion sin nombre definido (nombre por defecto de Moodle)': $section_name;
        $question_category->name = 'Preguntas de la sección: '.$section_name;
        $question_category->contextid = $context_id;
        $question_category->info = 'Categoría de preguntas generadas por IA de la sección '.$section_name;
        $top_question_category = $DB->get_field('question_categories', 'id', ['contextid' => $context_id, 'parent' => 0]);
        $question_category->parent = $DB->get_field("question_categories", 'id', ['contextid' => $context_id, 'parent' => $top_question_category]);
        $question_category->sortorder = 999;
        $question_category->stamp = make_unique_id_code();
        $question_category->createdby = $this->_user->id;
        $question_category->modifiedby = $this->_user->id;
        $question_category->timecreated = time();
        $question_category->timemodified = time();
        return $DB->insert_record('question_categories', $question_category);
    }
    private function process_merged_pdf($mergedPdfTempFilename)
    {
        $file_content = file_get_contents($mergedPdfTempFilename);
        $response = $this->call_api($file_content);
        return $response;
    }

    private function mergePDFs(array $files, string $outputFile): bool
    {
        try {
            $pdf = new Fpdi();

            foreach ($files as $file) {
                if (!file_exists($file)) {
                    throw new \RuntimeException("File not found: $file");
                }

                $pageCount = $pdf->setSourceFile($file);
                for ($i = 1; $i <= $pageCount; $i++) {
                    $tplId = $pdf->importPage($i);
                    $pdf->AddPage();
                    $pdf->useTemplate($tplId);
                }
            }

            $pdf->Output('F', $outputFile);

            // Free memory
            unset($pdf);
            gc_collect_cycles();

            return true;
        } catch (PdfParserException $e) {
            error_log("PDF Parser Error: " . $e->getMessage());
            return false;
        } catch (\RuntimeException $e) {
            error_log("Error: " . $e->getMessage());
            return false;
        }
    }

    private function add_question_to_question_bank($response, $question_category_id) {

        global $DB, $USER;

        foreach ($response as $question_data) {
            $question = new stdClass();
            $question->name = $question_data['question_name'];
            $question->questiontext = [
                'text' => $question_data['question_name'],
                'format' => FORMAT_HTML,
            ];
            $question->qtype = 'multichoice';
            $question->category = $question_category_id;
            $question->createdby = $USER->id;
            $question->modifiedby = $USER->id;
            $question->generalfeedbackformat = FORMAT_HTML;

            // Prepare the form object with required parameters.
            $qtype = question_bank::get_qtype('multichoice');
            $form = $this->_form;
            $form->category = $question->category;
            $form->questiontext = $question->questiontext;
            $form->penalty = 0.3333333;
            $form->single = 1;
            $form->correctfeedback['format'] = FORMAT_HTML;
            $form->incorrectfeedback['format'] = FORMAT_HTML;
            $form->partiallycorrectfeedback ['format'] = FORMAT_HTML;
            $form->answernumbering = 'abc';
            $form->shuffleanswers = 1;
            $form->correctfeedbackformat = 1;
            $form->partiallycorrectfeedbackformat = 1;
            $form->incorrectfeedbackformat = 1;

            // Populate answer choices, feedback and fractions.
            $form->answer = array();
            $form->feedback = array();
            $form->fraction = array();
            foreach ($question_data['answer_options'] as $index => $answer_text) {
                // Only add non-empty answers.
                if (trim($answer_text) === '') {
                    continue;
                }
                // Answer text with proper formatting.
                $form->answer[$index] = [
                    'text' => '<p dir="ltr" style="text-align: left;">' . $answer_text . '</p>',
                    'format' => FORMAT_HTML,
                ];
                // Default feedback; you can customize this as needed.
                $form->feedback[$index] = [
                    'text' => 'Your feedback here',
                    'format' => FORMAT_HTML,
                ];
                // Set fraction: 1.0 for correct answer, -1.0 or 0 for incorrect.
                $form->fraction[$index] = ($index == $question_data['correct_answer_index']) ? 1.0 : -1.0;
            }

            // Now save the question. The save_question() call will use $form->answer etc.
            $question = $qtype->save_question($question, $form);
            // Create the question bank entry.
            $question_bank_entry = new stdClass();
            $question_bank_entry->questioncategoryid = $question_category_id;
            $question_bank_entry->ownerid = $USER->id;
            $question_bank_entry_id = $DB->insert_record('question_bank_entries', $question_bank_entry);
            $question_version = new stdClass();
            $question_version->questionbankentryid = $question_bank_entry_id;
            $question_version->version = 1;
            $question_version->questionid = $question->id;
            $question_version->status = 'ready';


        }
    }

    private function get_pdfs_in_section() {
        global $DB;

        $files_in_section = [];
        $resource_id = $DB->get_field('modules', 'id', ['name' => 'resource']);

        // Obtener el ID de la sección
        $section_id = $DB->get_field('course_sections', 'id', ['section' => $this->_section]);

        if (!$section_id) {
            return [];
        }

        // Obtener los IDs de los módulos de recursos en la sección
        $module_ids = $DB->get_fieldset_select('course_modules', 'id', 'section = ? AND module = ?', [$section_id, $resource_id]);

        if (empty($module_ids)) {
            return [];
        }

        // Obtener los contextos de los módulos de recursos
        list($in_sql, $params) = $DB->get_in_or_equal($module_ids);
        $context_ids = $DB->get_fieldset_select('context', 'id', "instanceid $in_sql", $params);

        if (empty($context_ids)) {
            return [];
        }

        // Obtener los PDFs en estos contextos
        list($in_sql, $params) = $DB->get_in_or_equal($context_ids);
        $pdfs = $DB->get_records_sql("
        SELECT *
        FROM {files}
        WHERE contextid $in_sql
        AND component = 'mod_resource'
        AND filesize > 0
        AND filename <> '.'
        AND mimetype = 'application/pdf'
    ", $params);

        return $pdfs;
    }
    function format_text($text) {
        // Define the regex pattern. The pattern captures:
        //   1. The question text after "Pregunta:"
        //   2. Option A text after "A."
        //   3. Option B text after "B."
        //   4. Option C text after "C."
        //   5. Option D text after "D."
        //   6. The correct answer letter (A-D) after "Respuesta correcta:"
        $pattern = '/\s*Pregunta:\s*(.+?)\s*Opciones:\s*A\.\s*(.+?)\s*B\.\s*(.+?)\s*C\.\s*(.+?)\s*D\.\s*(.+?)\s*Respuesta correcta:\s*([A-D])\s*/s';

        // Use preg_match_all to find all matches in the provided text.
        // PREG_SET_ORDER makes $matches an array of match arrays.
        preg_match_all($pattern, $text, $matches, PREG_SET_ORDER);

        $questions_list = array();

        // Loop over each match and build the questions array.
        foreach ($matches as $match) {
            // $match indices:
            //   [1] -> question text
            //   [2] -> option A
            //   [3] -> option B
            //   [4] -> option C
            //   [5] -> option D
            //   [6] -> correct answer letter
            $question_name = $match[1];
            $answer_options = array($match[2], $match[3], $match[4], $match[5]);
            $correct_answer_index = ord($match[6]) - ord('A'); // Convert letter (A-D) to an index (0-3)

            $questions_list[] = array(
                'question_name' => $question_name,
                'answer_options' => $answer_options,
                'correct_answer_index' => $correct_answer_index
            );
        }

        // Return the questions list as a pretty-printed JSON string with unescaped Unicode characters.
        return $questions_list;
    }

    private function call_api($file)
    {
        $yourApiKey = $_ENV['OPENAI_API_KEY'];
        $client = OpenAI::client($yourApiKey);
        $file_upload_response = $this->upload_file_to_openai($client, $file);
        $create_assistant_response = $this->openai_create_assistant($client);
        $create_thread_response = $this->openai_create_thread($client, $file_upload_response->id, $create_assistant_response->id);
        return $create_thread_response;
    }

    private function upload_file_to_openai($client, $fileContent) {
        // Create a temporary file with a proper PDF extension.
        $tempFilename = tempnam(sys_get_temp_dir(), 'moodle_pdf_');
        $pdfFilename = $tempFilename . '.pdf';
        rename($tempFilename, $pdfFilename);

        // Write the PDF content.
        file_put_contents($pdfFilename, $fileContent);

        // Open the file as a resource.
        $fileResource = fopen($pdfFilename, 'r');

        // Upload the file using the file resource.
        $response = $client->files()->upload([
            'purpose' => 'assistants',
            'file'    => $fileResource,
        ]);


        unlink($pdfFilename);

        return $response;
    }

    private function openai_create_assistant($client){
        $response = $client->assistants()->create([
            'instructions' => 'Eres un generador de preguntas de opción múltiple en español basadas en documentos PDF.
            Genera preguntas únicas con 4 opciones de respuesta cada una, asegurando una única respuesta correcta por pregunta.

            Reglas estrictas:
            - No incluyas pistas en la redacción de las preguntas.
            - Cubre todo el documento con las preguntas, no solo fragmentos.
            - Varía la posición de la respuesta correcta para evitar patrones predecibles.
            - Usa español, salvo términos sin traducción en el texto original.
            - No preguntes sobre ubicaciones (página/sección) dentro del documento.
            - Evita preguntas de definición directa; prioriza preguntas conceptuales y aplicadas.
            - No formules preguntas cuya respuesta se mencione directamente en el enunciado.
            - Si no es posible generar 10 preguntas, proporciona tantas como sea posible siguiendo el mismo formato.

            Formato de salida:
                [Número]. Pregunta: [Texto de la pregunta]
                Opciones:
                A. [Opción 1]
                B. [Opción 2]
                C. [Opción 3]
                D. [Opción 4]
                Respuesta correcta: [Letra]',
            'name' => 'Moodle PDF to Quiz Generator',
            'tools' => [
                [
                    'type' => 'file_search',
                ],
            ],
            'model' => "gpt-4o-mini",
        ]);
        return $response;
    }

    private function openai_create_thread($client, $file_id, $assistant_id){
        $thread_create_response = $client->threads()->create([]);

        $client->threads()->messages()->create($thread_create_response->id, [
            'role' => 'assistant',
            'content' => 'Genera 10 preguntas para un cuestionario basándote en el documento adjuntado, que estará formado de una fusión de varios pdfs en uno solo.',
            'attachments' => [
                [
                    'file_id' => $file_id,
                    'tools' => [
                        [
                            'type' => 'file_search',
                        ],
                    ],
                ],
            ],
        ]);
        $response = $client->threads()->runs()->create(
            threadId: $thread_create_response->id,
            parameters: [
                'assistant_id' => $assistant_id,
            ],
        );

        $maxAttempts = 100; // or however many times you want to check
        $attempt = 0;

        do {
            sleep(1); // wait for a second (adjust as needed)
            $runStatus = $response = $client->threads()->runs()->retrieve(
                threadId: $thread_create_response->id,
                runId: $response->id,
            );
            $attempt++;
        } while ($runStatus->status !== 'completed' && $attempt < $maxAttempts);

        if ($runStatus->status === 'completed') {
            $response = $client->threads()->messages()->list($thread_create_response->id);
            return $response->data[0]->content[0]->text->value;
        } else {
            throw new Exception('Run did not complete in the expected time.');
        }
    }
}